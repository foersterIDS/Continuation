%% path continuation - aux.initialize_structs
%
%   Institute of Dynamics and Vibration Research
%   Leibniz University Hannover
%   16.09.2021 - Alwin FÃ¶rster
%
function [Bifurcation,Counter,Do,Info,Info_out,Initial,Is,Jacobian,Path,Plot,Plus,Remove,Solver,Stepsize_information,Temp] = initialize_structs(var0,l_start,l_end,ds0,Opt,output_flag)
    %% Bifurcation
    %
    Bifurcation = struct('bif',[],...
                         'dirs',{cell(1,2)},...
                         'flag',0);
    %
    %% Counter
    %
    Counter = struct('catch',0,...
                     'catch_old',0,...
                     'closed_curve',0,...
                     'error',0,...
                     'event',0,...
                     'loop',0,...
                     'remove',0,...
                     'step',0,...
                     'valid_stepback',0);
    %
    %% Do
    %
    Do = struct('change_corrector',false,...
                'continuation',false,...
                'convergeToTarget',false,...
                'deflate',false,...
                'homotopy',false,...
                'loop',false,...
                'remove',false,...
                'stepback',false,...
                'stop_manually',false,...
                'suspend',false);
	%
    %% Info
    %
    Info = struct('ds0',ds0,...
                  'exitflag',-1,...
                  'exit_msg','',...
                  'nv',numel(var0),...
                  'l_start',l_start,...
                  'l_end',l_end,...
                  'var0',var0);
	%
    %% Info_out
    %
    Info_out = struct('number_of_steps',0,...
                      'number_of_invalid_points',0);
    %
    %% Initial
    %
    Initial = struct('ds_max',Opt.ds_max);
    %
    %% Is
    %
    Is = struct('catch',false,...
                'current_jacobian',false,...
                'reverse',false,...
                'valid',false);
    %
    %% Jacobian
    %
    Jacobian = struct('initial',[],...
                      'last',[],...
                      'previous',[],...
                      'sign_det',1,...
                      'solver',[]);
    %
    %% Path
    %
    Path = struct('l_all',[],...
                  's_all',[],...
                  'speed_of_continuation',[],...
                  'var_all',[],...
                  'x_predictor',[]);
	%
    %% Plot
    %
    if (aux.ison(Opt.plot) && ~Opt.plot.detail) || ~aux.ison(Opt.plot)
        Plot = struct('fig',[],...
                      'pl',[],...
                      'pl_curr',[]);
    else
        Plot = struct('fig',[],...
                      'pl',[],...
                      'pl_cor',[],...
                      'pl_cor_assist',[],...
                      'pl_curr',[],...
                      'pl_det',[],...
                      'pl_it',[],...
                      'pl_pre',[],...
                      'pl_s',[]);
    end
	%
    %% Plus
    %
    Plus = struct('jacobian',[],...
                  'rate_of_contraction',[],...
                  'speed_of_continuation',[],...
                  'x',[],...
                  'x_predictor',[]);
    %
    %% Remove
    %
    Remove = struct('ds',NaN,...
                    's',NaN);
    %
    %% Solver
    %
    [solver,predictor_solver,num_jac_solver,default_solver_output] = continuation.solver(Opt,output_flag);
    Solver = struct('default_output',default_solver_output,...
                    'exitflag',-2,...
                    'main',solver,...
                    'num_jac',num_jac_solver,...
                    'output',default_solver_output,...
                    'predictor',predictor_solver);
    %
    %% Stepsize_information
    %
    Stepsize_information = struct('rate_of_contraction',NaN,...
                                  'speed_of_continuation',NaN);
    %
    %% Temp
    %
    Temp = struct('flag',[],...
                  'iterations',[],...
                  'length',[],...
                  'predictor',[],...
                  'rate_of_contraction',[],...
                  'speed_of_continuation',[]);
    %
end